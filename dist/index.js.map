{"version":3,"sources":["../src/fluent.ts"],"sourcesContent":["type AddApiKeys<T, U> = {\n  [K in keyof U]: U[K] extends (...args: infer P) => any\n    ? P extends [infer Ctx, ...infer Rest]\n      ? (...args: Rest) => AddConfigPropAndReturn<U, U>\n      : AddConfigPropAndReturn<U, U>\n    : AddConfigPropAndReturn<U[K], U>;\n};\n\nexport type AddConfigPropAndReturn<T, U> = T extends (...args: any[]) => any\n  ? Parameters<T> extends [infer Ctx, ...infer Rest]\n    ? ((...args: Rest) => AddConfigPropAndReturn<U, U>) & AddApiKeys<T, U>\n    : AddConfigPropAndReturn<U, U> & AddApiKeys<T, U>\n  : {\n      [P in keyof T]: T[P] extends (...args: any[]) => any\n        ? Parameters<T[P]> extends [infer Ctx, ...infer Rest]\n          ? ((...args: Rest) => AddConfigPropAndReturn<U, U>) & AddApiKeys<T, U>\n          : AddConfigPropAndReturn<U, U> & AddApiKeys<T, U> & T[P]\n        : AddConfigPropAndReturn<T[P], U>;\n    } & AddApiKeys<T, U>;\n\nexport type FluentApi<V, U> = AddConfigPropAndReturn<V, U>;\n\nexport type CombinedFluentApi<T> = {\n  [K in keyof T]: FluentApi<T[K], T>;\n};\n\nexport type ApiCall = { method: string; args?: any[] };\n\nexport function fluent<T extends Record<string, any>>(\n  api: T\n): CombinedFluentApi<T> {\n  let chain: any = null;\n\n  const createProxy = (\n    parentCalls: ApiCall[] = [],\n    path: string[] = []\n  ): any => {\n    const calls = [...parentCalls];\n\n    const run = (ctx: any) => {\n      const executeAsyncOps = async (firstPromise: Promise<any>, atIndex: number) => {\n        ctx = await firstPromise;\n        for (let i = atIndex + 1; i < calls.length; i++) {\n          ctx = await executeOp(calls[i]);\n        }\n        return ctx;\n      };\n\n      const executeOp = (item: any) => {\n        const { method: path, args = [] } = item;\n        const splitPath = path.split(\".\");\n        const method = splitPath.reduce((acc, key) => acc[key], api);\n        return method({ ctx, chain }, ...args);\n      };\n    \n      for (let i = 0; i < calls.length; i++) {\n        const result = executeOp(calls[i]);\n        if (result instanceof Promise) {\n          return executeAsyncOps(result, i);\n        }\n        ctx = result;\n      }\n      return ctx;\n    }\n\n    const handler: ProxyHandler<any> = {\n      get(_, prop: string | symbol): any {\n        if (prop === \"run\") return run;\n        if (prop === \"toJSON\") return () => calls;\n        if (typeof prop !== \"string\") return undefined;\n\n        const baseTarget =\n          prop in api ? api[prop] : undefined;\n        const newPath = baseTarget ? [prop] : [...path, prop];\n        const fullPath = newPath.join(\".\");\n        const target =\n          baseTarget || newPath.reduce((acc, key) => acc[key], api);\n\n        if (typeof target === \"object\") {\n          return createProxy(calls, newPath);\n        }\n\n        if (typeof target === \"function\") {\n          const func = target as Function;\n          if (func.length <= 1) {\n            return createProxy([...calls, { method: fullPath }], path);\n          }\n          return (...args: any[]) => {\n            return createProxy([...calls, { method: fullPath, args }], path);\n          };\n        }\n\n        return undefined;\n      },\n    };\n\n    return new Proxy(() => {}, handler);\n  };\n\n  chain = createProxy() as CombinedFluentApi<T>;\n  return chain;\n}\n\nexport const toChain = (op: string, fluent: any): any => {\n  const config: ApiCall[] =\n    typeof op === \"string\" ? JSON.parse(op) : JSON.parse(JSON.stringify(op));\n\n  let current = fluent;\n  for (const { method, args } of config) {\n    const methods = method.split(\".\");\n    for (const m of methods) {\n      if (methods.indexOf(m) === methods.length - 1 && args?.length) {\n        current = current[m](...(args || []));\n        continue;\n      }\n      current = current[m];\n    }\n  }\n\n  return current;\n};\n"],"mappings":";AA4BO,SAAS,OACd,KACsB;AACtB,MAAI,QAAa;AAEjB,QAAM,cAAc,CAClB,cAAyB,CAAC,GAC1B,OAAiB,CAAC,MACV;AACR,UAAM,QAAQ,CAAC,GAAG,WAAW;AAE7B,UAAM,MAAM,CAAC,QAAa;AACxB,YAAM,kBAAkB,OAAO,cAA4B,YAAoB;AAC7E,cAAM,MAAM;AACZ,iBAAS,IAAI,UAAU,GAAG,IAAI,MAAM,QAAQ,KAAK;AAC/C,gBAAM,MAAM,UAAU,MAAM,CAAC,CAAC;AAAA,QAChC;AACA,eAAO;AAAA,MACT;AAEA,YAAM,YAAY,CAAC,SAAc;AAC/B,cAAM,EAAE,QAAQA,OAAM,OAAO,CAAC,EAAE,IAAI;AACpC,cAAM,YAAYA,MAAK,MAAM,GAAG;AAChC,cAAM,SAAS,UAAU,OAAO,CAAC,KAAK,QAAQ,IAAI,GAAG,GAAG,GAAG;AAC3D,eAAO,OAAO,EAAE,KAAK,MAAM,GAAG,GAAG,IAAI;AAAA,MACvC;AAEA,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,cAAM,SAAS,UAAU,MAAM,CAAC,CAAC;AACjC,YAAI,kBAAkB,SAAS;AAC7B,iBAAO,gBAAgB,QAAQ,CAAC;AAAA,QAClC;AACA,cAAM;AAAA,MACR;AACA,aAAO;AAAA,IACT;AAEA,UAAM,UAA6B;AAAA,MACjC,IAAI,GAAG,MAA4B;AACjC,YAAI,SAAS,MAAO,QAAO;AAC3B,YAAI,SAAS,SAAU,QAAO,MAAM;AACpC,YAAI,OAAO,SAAS,SAAU,QAAO;AAErC,cAAM,aACJ,QAAQ,MAAM,IAAI,IAAI,IAAI;AAC5B,cAAM,UAAU,aAAa,CAAC,IAAI,IAAI,CAAC,GAAG,MAAM,IAAI;AACpD,cAAM,WAAW,QAAQ,KAAK,GAAG;AACjC,cAAM,SACJ,cAAc,QAAQ,OAAO,CAAC,KAAK,QAAQ,IAAI,GAAG,GAAG,GAAG;AAE1D,YAAI,OAAO,WAAW,UAAU;AAC9B,iBAAO,YAAY,OAAO,OAAO;AAAA,QACnC;AAEA,YAAI,OAAO,WAAW,YAAY;AAChC,gBAAM,OAAO;AACb,cAAI,KAAK,UAAU,GAAG;AACpB,mBAAO,YAAY,CAAC,GAAG,OAAO,EAAE,QAAQ,SAAS,CAAC,GAAG,IAAI;AAAA,UAC3D;AACA,iBAAO,IAAI,SAAgB;AACzB,mBAAO,YAAY,CAAC,GAAG,OAAO,EAAE,QAAQ,UAAU,KAAK,CAAC,GAAG,IAAI;AAAA,UACjE;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO,IAAI,MAAM,MAAM;AAAA,IAAC,GAAG,OAAO;AAAA,EACpC;AAEA,UAAQ,YAAY;AACpB,SAAO;AACT;AAEO,IAAM,UAAU,CAAC,IAAYC,YAAqB;AACvD,QAAM,SACJ,OAAO,OAAO,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,MAAM,KAAK,UAAU,EAAE,CAAC;AAEzE,MAAI,UAAUA;AACd,aAAW,EAAE,QAAQ,KAAK,KAAK,QAAQ;AACrC,UAAM,UAAU,OAAO,MAAM,GAAG;AAChC,eAAW,KAAK,SAAS;AACvB,UAAI,QAAQ,QAAQ,CAAC,MAAM,QAAQ,SAAS,MAAK,6BAAM,SAAQ;AAC7D,kBAAU,QAAQ,CAAC,EAAE,GAAI,QAAQ,CAAC,CAAE;AACpC;AAAA,MACF;AACA,gBAAU,QAAQ,CAAC;AAAA,IACrB;AAAA,EACF;AAEA,SAAO;AACT;","names":["path","fluent"]}