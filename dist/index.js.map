{"version":3,"sources":["../src/index.ts","../src/fluent.ts"],"sourcesContent":["export * from \"./fluent\";","type AddApiKeys<T, U> = {\n  [K in keyof U]: U[K] extends (...args: infer P) => any\n    ? P extends [infer Ctx, ...infer Rest]\n      ? (...args: Rest) => AddConfigPropAndReturn<U, U>\n      : AddConfigPropAndReturn<U, U>\n    : AddConfigPropAndReturn<U[K], U>;\n};\n\nexport type AddConfigPropAndReturn<T, U> = T extends (...args: any[]) => any\n  ? Parameters<T> extends [infer Ctx, ...infer Rest]\n    ? ((...args: Rest) => AddConfigPropAndReturn<U, U>) & AddApiKeys<T, U>\n    : AddConfigPropAndReturn<U, U> & AddApiKeys<T, U>\n  : {\n      [P in keyof T]: T[P] extends (...args: any[]) => any\n        ? Parameters<T[P]> extends [infer Ctx, ...infer Rest]\n          ? ((...args: Rest) => AddConfigPropAndReturn<U, U>) & AddApiKeys<T, U>\n          : AddConfigPropAndReturn<U, U> & AddApiKeys<T, U> & T[P]\n        : AddConfigPropAndReturn<T[P], U>;\n    } & AddApiKeys<T, U>;\n\nexport type FluentApi<V, U> = AddConfigPropAndReturn<V, U>;\n\nexport type CombinedFluentApi<T> = {\n  [K in keyof T]: FluentApi<T[K], T>;\n};\n\nexport type ApiCall = { method: string; args?: any[] };\n\nexport function fluent<T extends Record<string, any>>(apiStructure: T): CombinedFluentApi<T> {\n  const createProxy = (parentCalls: ApiCall[] = [], currentPath: string[] = [], currentTarget: any = apiStructure): any => {\n    const calls = [...parentCalls];\n\n    const handler: ProxyHandler<any> = {\n      get(_, prop: string | symbol): any {\n        if (prop === 'toJSON') {\n          return () => calls;\n        }\n\n        if (typeof prop === 'string') {\n          const newPath = [...currentPath, prop];\n          const fullPath = newPath.join('.');\n\n          // Check if the current property is a namespace\n          const isNamespace = typeof currentTarget[prop] === 'object';\n\n          if (isNamespace) {\n            // If it's a namespace, continue building the path without adding to calls\n            return createProxy(calls, newPath, currentTarget[prop]);\n          } else {\n            // Check if the property is a new top-level API\n            if (prop in apiStructure) {\n              // Switch to a new API\n              return createProxy(calls, [prop], apiStructure[prop]);\n            }\n\n            // If it's not a namespace, add it to calls\n            calls.push({ method: fullPath });\n\n            const proxy = new Proxy(function (...args: any[]) {\n              calls[calls.length - 1].args = args;\n              // Keep the full current path\n              return createProxy(calls, currentPath, currentTarget);\n            }, handler);\n\n            return proxy;\n          }\n        }\n\n        return undefined;\n      }\n    };\n\n    const isFunction = typeof currentTarget === \"function\";\n    const func = isFunction ? (...args: any[]) => {\n      calls.push({ method: currentPath.join('.'), args });\n      return createProxy(calls, currentPath, currentTarget);\n    } : () => { };\n\n    const proxy = new Proxy(func, handler);\n    (proxy as any).toJSON = () => calls;\n\n    return proxy;\n  };\n\n  const rootProxy = new Proxy({}, {\n    get(_, prop: string | symbol): any {\n      if (prop === 'toJSON') {\n        return () => [];\n      }\n\n      return createProxy([], [prop as string], apiStructure[prop as string]);\n    }\n  }) as CombinedFluentApi<T>;\n\n  (rootProxy as any).toJSON = () => [];\n\n  return rootProxy;\n}\n\ntype Ctx = any;\n\nexport const run = async ({ op, ctx: _ctx, api }: { op: any; ctx: Ctx; api: any }): Promise<any> => {\n  const config = typeof op === 'string' ? JSON.parse(op) : JSON.parse(JSON.stringify(op));\n  const ctx = _ctx as Ctx;\n\n  const runHelper = async (op: any) => {\n    return await run({ op, ctx, api });\n  }\n\n  const executeOperation = async (item: any) => {\n    const { method: path, args = [] } = item;\n    const splitPath = path.split(\".\");\n    const method = splitPath.reduce((acc, key) => acc[key], api);\n    return method({ctx, run: runHelper }, ...args);\n  };\n\n  for (let i = 0; i < config.length; i++) {\n    await executeOperation(config[i]);\n  }\n\n  return ctx;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC4BO,SAAS,OAAsC,cAAuC;AAC3F,QAAM,cAAc,CAAC,cAAyB,CAAC,GAAG,cAAwB,CAAC,GAAG,gBAAqB,iBAAsB;AACvH,UAAM,QAAQ,CAAC,GAAG,WAAW;AAE7B,UAAM,UAA6B;AAAA,MACjC,IAAI,GAAG,MAA4B;AACjC,YAAI,SAAS,UAAU;AACrB,iBAAO,MAAM;AAAA,QACf;AAEA,YAAI,OAAO,SAAS,UAAU;AAC5B,gBAAM,UAAU,CAAC,GAAG,aAAa,IAAI;AACrC,gBAAM,WAAW,QAAQ,KAAK,GAAG;AAGjC,gBAAM,cAAc,OAAO,cAAc,IAAI,MAAM;AAEnD,cAAI,aAAa;AAEf,mBAAO,YAAY,OAAO,SAAS,cAAc,IAAI,CAAC;AAAA,UACxD,OAAO;AAEL,gBAAI,QAAQ,cAAc;AAExB,qBAAO,YAAY,OAAO,CAAC,IAAI,GAAG,aAAa,IAAI,CAAC;AAAA,YACtD;AAGA,kBAAM,KAAK,EAAE,QAAQ,SAAS,CAAC;AAE/B,kBAAMA,SAAQ,IAAI,MAAM,YAAa,MAAa;AAChD,oBAAM,MAAM,SAAS,CAAC,EAAE,OAAO;AAE/B,qBAAO,YAAY,OAAO,aAAa,aAAa;AAAA,YACtD,GAAG,OAAO;AAEV,mBAAOA;AAAA,UACT;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AAEA,UAAM,aAAa,OAAO,kBAAkB;AAC5C,UAAM,OAAO,aAAa,IAAI,SAAgB;AAC5C,YAAM,KAAK,EAAE,QAAQ,YAAY,KAAK,GAAG,GAAG,KAAK,CAAC;AAClD,aAAO,YAAY,OAAO,aAAa,aAAa;AAAA,IACtD,IAAI,MAAM;AAAA,IAAE;AAEZ,UAAM,QAAQ,IAAI,MAAM,MAAM,OAAO;AACrC,IAAC,MAAc,SAAS,MAAM;AAE9B,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,IAAI,MAAM,CAAC,GAAG;AAAA,IAC9B,IAAI,GAAG,MAA4B;AACjC,UAAI,SAAS,UAAU;AACrB,eAAO,MAAM,CAAC;AAAA,MAChB;AAEA,aAAO,YAAY,CAAC,GAAG,CAAC,IAAc,GAAG,aAAa,IAAc,CAAC;AAAA,IACvE;AAAA,EACF,CAAC;AAED,EAAC,UAAkB,SAAS,MAAM,CAAC;AAEnC,SAAO;AACT;AAIO,IAAM,MAAM,OAAO,EAAE,IAAI,KAAK,MAAM,IAAI,MAAqD;AAClG,QAAM,SAAS,OAAO,OAAO,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,MAAM,KAAK,UAAU,EAAE,CAAC;AACtF,QAAM,MAAM;AAEZ,QAAM,YAAY,OAAOC,QAAY;AACnC,WAAO,MAAM,IAAI,EAAE,IAAAA,KAAI,KAAK,IAAI,CAAC;AAAA,EACnC;AAEA,QAAM,mBAAmB,OAAO,SAAc;AAC5C,UAAM,EAAE,QAAQ,MAAM,OAAO,CAAC,EAAE,IAAI;AACpC,UAAM,YAAY,KAAK,MAAM,GAAG;AAChC,UAAM,SAAS,UAAU,OAAO,CAAC,KAAK,QAAQ,IAAI,GAAG,GAAG,GAAG;AAC3D,WAAO,OAAO,EAAC,KAAK,KAAK,UAAU,GAAG,GAAG,IAAI;AAAA,EAC/C;AAEA,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,iBAAiB,OAAO,CAAC,CAAC;AAAA,EAClC;AAEA,SAAO;AACT;","names":["proxy","op"]}