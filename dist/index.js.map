{"version":3,"sources":["../src/string.ts","../src/fluent.ts"],"sourcesContent":["import { fluent } from \"./fluent\";\nimport { ApiCall, Fluent } from \"./types\";\n\n/**\n * Converts an array of API calls back into a method chaining string.\n * @param calls - An array of API calls.\n * @returns The method chaining string.\n */\nexport function chainToString(calls: ApiCall[]): string {\n  return calls\n    .map((call) => {\n      const args = call.args?.length ? `(${call.args.join(\", \")})` : \"\";\n      return `${call.method}${args}`;\n    })\n    .join(\".\");\n}\n\n/**\n * Parses an array of argument strings, attempting to convert each into its appropriate type.\n * If the argument is a method chain, it is recursively processed.\n * @param args - The array of argument strings to parse.\n * @param baseApi - The base API object containing methods and properties.\n * @returns An array of parsed arguments.\n */\nfunction parseArguments(args: any[], baseApi: Record<string, any>): any[] {\n  args = Array.isArray(args) ? args : [args];\n  return args.map(arg => {\n    try {\n      // Try to parse as JSON\n      return JSON.parse(arg);\n    } catch {\n      // If parsing fails, treat it as a method chain\n      return stringToChain(baseApi, arg);\n    }\n  });\n}\n\n/**\n * Creates a mock method that returns its full method path and parsed arguments.\n * @param path - The full path of the method within the API.\n * @param baseApi - The base API object containing methods and properties.\n * @param argLength - The number of arguments the method accepts.\n * @returns A function that simulates the method call, returning the method path and arguments.\n */\nfunction createMockMethod(\n  path: string,\n  baseApi: Record<string, any>,\n  argLength: number\n): (data: any, args: any[]) => { method: string; args: any[] } {\n  if (argLength < 2) {\n    return function (data: any): { method: string; args: any[] } {\n      return { method: path, args: [] };\n    };\n  } else {\n    return function (data: any, args): { method: string; args: any[] } {\n      const parsedArgs = parseArguments(args, baseApi);\n      return { method: path, args: parsedArgs };\n    };\n  }\n}\n\n/**\n * Recursively traverses an API object to build a mock API where each method is replaced\n * with a function that returns the method's full path and arguments.\n * @param api - The API object to traverse.\n * @param path - The current path of the method being traversed.\n * @param baseApi - The base API object containing methods and properties.\n * @returns A mock API object with methods that return their path and arguments.\n */\nfunction traverseApi(\n  api: Record<string, any>,\n  path: string = \"\",\n  baseApi: Record<string, any>\n): Record<string, any> {\n  const mock: Record<string, any> = {};\n  for (let key in api) {\n    const currentPath = path ? `${path}.${key}` : key;\n    if (typeof api[key] === \"function\") {\n      mock[key] = createMockMethod(currentPath, baseApi, api[key].length);\n    } else if (typeof api[key] === \"object\" && api[key] !== null) {\n      mock[key] = traverseApi(api[key], currentPath, baseApi);\n    }\n  }\n  return mock;\n}\n\n/**\n * Builds a mock API by traversing the base API and replacing methods with mock methods\n * that return their path and arguments.\n * @param baseApi - The base API object containing methods and properties.\n * @returns A mock API object.\n */\nfunction buildMockApi(baseApi: Record<string, any>): Record<string, any> {\n  return traverseApi(baseApi, \"\", baseApi);\n}\n\n/**\n * Executes a method chain on the mock API by parsing the method chain string\n * and invoking the appropriate methods on the mock API.\n * @param api - The base API object containing methods and properties.\n * @param str - The method chain string to execute.\n * @returns The result of executing the method chain on the mock API.\n */\nexport function stringToChain(api: Record<string, any>, str: string): any {\n  const mockApi = buildMockApi(api);\n  const mockRoot = fluent({ api: mockApi, ctx: {} });\n\n  const splitPath = str.split('.');\n  const path: string[] = [];\n  let current: string = '';\n\n  // Parse the method chain string into a list of method calls\n  splitPath.forEach(part => {\n    current += part;\n    const openBrackets = (current.match(/\\(/g) || []).length;\n    const closeBrackets = (current.match(/\\)/g) || []).length;\n\n    if (openBrackets === closeBrackets) {\n      path.push(current);\n      current = '';\n    } else {\n      current += '.';\n    }\n  });\n\n  // Traverse the parsed path on the mockRoot\n  let currentNode: any = mockRoot;\n  path.forEach(part => {\n    // Extract method name and arguments\n    const methodName = part.replace(/\\(.*\\)/, '');\n    const argsMatch = part.match(/\\((.*)\\)/);\n    const args = argsMatch ? argsMatch[1] : null;\n    if (args) currentNode = currentNode[methodName](args);\n    else currentNode = currentNode[methodName];\n  });\n\n  // Execute the final method in the chain\n  return [currentNode.run()];\n}","import { chainToString, stringToChain } from \"./string\";\nimport { ApiCall, Ctx, Fluent, RequiredContext, StringChain } from \"./types\";\n\n/**\n * Executes a method from the API with the provided context and arguments.\n * @param api - The API object containing the methods.\n * @param ctx - The context object passed to the method.\n * @param call - An object containing the method name and arguments.\n * @returns The result of the method execution.\n */\nfunction runMethod(api: Record<string, any>, ctx: any, call: ApiCall) {\n  const { method, args } = call;\n  const methodFunc: any = method.split(\".\").reduce((acc, key) => acc[key], api);\n  return methodFunc(ctx, ...(args || []));\n}\n\n/**\n * Executes a sequence of API calls, handling promises for asynchronous operations.\n * @param api - The API object containing the methods.\n * @param data - The initial context object.\n * @param firstResult - The result of the first API call.\n * @param calls - An array of subsequent API calls to execute.\n * @returns A promise that resolves to the final context after all calls are executed.\n */\nasync function runPromises(\n  api: Record<string, any>,\n  data: any,\n  firstResult: Promise<any>,\n  calls: ApiCall[]\n) {\n  await firstResult;\n  data = firstResult === undefined ? data : firstResult;\n  for (const call of calls) {\n    const result = runMethod(api, data, call);\n    if (result instanceof Promise) {\n      await result;\n    }\n    data = result === undefined ? data : result;\n  }\n  return data;\n}\n\n/**\n * Finds the index of the next API call in the chain that matches the specified call.\n * @param calls - The list of API calls.\n * @param call - The API call to find in the list.\n * @param current - The current index in the list of API calls.\n * @returns The index of the matching call, or -1 if not found.\n */\nfunction callIndex(calls: ApiCall[], call: ApiCall, current: number) {\n  const remaining = calls.slice(current + 1);\n  const gotoCall = JSON.stringify(call);\n  const nextIndex = remaining.findIndex((c) => JSON.stringify(c) === gotoCall);\n  if (nextIndex > -1) {\n    return nextIndex;\n  }\n  const start = calls.slice(0, current + 1);\n  const prevIndex = start.findIndex(\n    ({ goto, ...c }) => JSON.stringify(c) === gotoCall\n  );\n  return prevIndex;\n}\n\n/**\n * Creates a proxy object that allows fluent method chaining for the given API.\n * @param api - The API object containing methods and properties.\n * @param parentCalls - The list of previous API calls.\n * @param path - The current path of method calls.\n * @param ctx - The context configuration object.\n * @returns A proxy object that supports method chaining.\n */\nfunction createProxy<T extends Record<string, any>>(\n  api: T,\n  parentCalls: ApiCall[],\n  path: string[],\n  ctx: Ctx\n): any {\n  const calls = [...parentCalls];\n\n  const run = (data: any, from = 0) => {\n    let goto = -1;\n    for (let i = from; i < calls.length; i++) {\n      let call = calls[i];\n      if (call.goto && call.goto.args) {\n        const index = callIndex(calls, call.goto.args[0], i);\n        if (index > -1) goto = index;\n      }\n      const result = runMethod(api, data, call);\n      if (result instanceof Promise) {\n        const remaining = calls.slice(calls.indexOf(call) + 1);\n        return runPromises(api, data, result, remaining);\n      }\n      data = result === undefined ? data : result;\n      if (goto > -1) continue;\n    }\n    if (goto > -1) {\n      if (ctx?.fluent?.blocking) {\n        return run(data, goto);\n      }\n      {\n        setTimeout(() => run(data, goto), 0);\n      }\n    }\n    return data;\n  };\n\n  const handler: ProxyHandler<any> = {\n    get(_, prop: string | symbol): any {\n      if (prop === \"run\") return run;\n      if (prop === \"toJSON\") return () => calls;\n      if (prop === \"goto\")\n        return (call: ApiCall) => {\n          const goto = {\n            method: \"goto\",\n            args: JSON.parse(JSON.stringify(call)),\n          };\n          calls[calls.length - 1].goto = goto;\n          return createProxy(api, [...calls], path, ctx);\n        };\n      if (prop === \"toString\") return () => chainToString(calls);\n\n      if (typeof prop !== \"string\") return undefined;\n\n      const baseTarget = prop in api ? api[prop] : undefined;\n      const newPath = baseTarget ? [prop] : [...path, prop];\n      const fullPath = newPath.join(\".\");\n      const targetValue = newPath.reduce((acc, key) => acc[key], api);\n\n      if (typeof targetValue === \"object\" && targetValue !== null) {\n        return createProxy(api, calls, newPath, ctx);\n      }\n\n      if (typeof targetValue === \"function\") {\n        const func = targetValue as Function;\n        if (func.length <= 1) {\n          return createProxy(api, [...calls, { method: fullPath }], path, ctx);\n        }\n        return (...args: any[]) => {\n          return createProxy(\n            api,\n            [...calls, { method: fullPath, args }],\n            path,\n            ctx\n          );\n        };\n      }\n\n      return undefined;\n    },\n  };\n\n  return new Proxy(() => {}, handler);\n}\n\n/**\n * Binds a context object to all functions within an API, allowing them to use the context as `this`.\n * @param api - The API object containing methods and properties.\n * @param ctx - The context object to bind to the API functions.\n * @returns The API object with context-bound functions.\n */\nfunction bindConfigToApi<T extends Record<string, any>>(api: T, ctx: Ctx): T {\n  const boundApi = {} as T;\n\n  for (const key in api) {\n    if (typeof api[key] === \"function\") {\n      // Bind the configuration to the function\n      boundApi[key] = api[key].bind(ctx);\n    } else if (typeof api[key] === \"object\" && api[key] !== null) {\n      // Recursively bind the configuration for nested objects\n      boundApi[key] = bindConfigToApi(api[key], ctx);\n    } else {\n      boundApi[key] = api[key];\n    }\n  }\n\n  return boundApi;\n}\n\n/**\n * Traverses the chain and its arguments. Recursively processes each element, converting serialized chains back into fluent interfaces,\n * and handling primitives, objects, and nested structures as needed.\n * @param chain - The chain to traverse.\n * @param api - The API object containing methods and properties.\n * @param ctx - The context object required by the API methods.\n * @returns The chain with serialized chains and nested structures converted into their appropriate forms.\n */\nexport function initChain<T extends Record<string, any>>(\n  chain: ApiCall[],\n  api: T,\n  ctx: RequiredContext<T>\n): ApiCall[] {\n  return chain.map((call) => {\n    if (call.args) {\n      call.args = call.args.map((arg) => processArgument(arg, api, ctx));\n    }\n    return call;\n  });\n}\n\n/**\n * Processes individual arguments within an API call, handling arrays, objects, and primitives.\n * @param arg - The argument to process.\n * @param api - The API object containing methods and properties.\n * @param ctx - The context object required by the API methods.\n * @returns The processed argument, potentially converted back into a fluent interface.\n */\nfunction processArgument<T extends Record<string, any>>(\n  arg: any,\n  api: T,\n  ctx: RequiredContext<T>\n): any {\n  const isArray = Array.isArray(arg);\n  const isObject = !isArray && typeof arg === \"object\" && arg !== null;\n\n  if (isArray) {\n    // Handle arrays that may contain serialized chains or other arrays\n    if (arg.every((a) => \"method\" in a)) {\n      return fluent({ api, chain: arg, ctx });\n    }\n    return arg.map((item) => processArgument(item, api, ctx)); // Recurse for nested arrays\n  }\n\n  if (isObject) {\n    // Handle objects by recursively processing each property\n    for (const key in arg) {\n      arg[key] = processArgument(arg[key], api, ctx);\n    }\n    return arg;\n  }\n\n  // Return primitive values as-is\n  return arg;\n}\n\n/**\n * Recursively traverses an object to find all method paths and their arities.\n * @param obj - The object to traverse.\n * @param path - The current path in the object.\n * @param paths - The list of method paths and their arities.\n * @returns An array of method paths and their arities.\n */\nfunction getMethodPaths(obj: Record<string, any>, path = \"\", paths: { path: string; arity: number }[] = []) {\n  for (let key in obj) {\n    if (typeof obj[key] === \"function\") {\n      paths.push({ path: path + key, arity: obj[key].length });\n    } else if (typeof obj[key] === \"object\" && obj[key] !== null) {\n      getMethodPaths(obj[key], path + key + \".\", paths);\n    }\n  }\n  return paths.sort((a, b) => b.path.length - a.path.length);\n}\n\n/**\n * Generates a regular expression pattern to match method calls in a string.\n * @param api - The API object containing methods and properties.\n * @returns A regular expression pattern that matches method calls.\n */\nfunction getMethodRegex(api: Record<string, any>): RegExp {\n  const methodPaths = getMethodPaths(api);\n\n  // Sort method paths by length in descending order to prefer longer matches\n  methodPaths.sort((a, b) => b.path.length - a.path.length);\n\n  // Build regex strings for each method path\n  const methodRegexes = methodPaths.map(({ path, arity }) => {\n    const escapedPath = path.replace(/\\./g, \"\\\\.\");\n    // Handle methods with and without arguments differently\n    if (arity < 2) {\n      return `${escapedPath}\\\\b`; // Match method names exactly\n    } else {\n      // For methods with arguments, capture nested parentheses\n      return `${escapedPath}\\\\((?:[^)(]+|\\\\((?:[^)(]+|\\\\([^)(]*\\\\))*\\\\))*\\\\)`;\n    }\n  });\n\n  // Combine all method regexes into one large regex pattern\n  return new RegExp(`(${methodRegexes.join(\"|\")})`, \"g\");\n}\n\n\n/**\n * Creates a fluent interface for the given API, allowing for method chaining and context management.\n * @param params - The parameters for creating the fluent interface.\n * @param params.api - The API object containing methods and properties.\n * @param params.chain - The initial chain of API calls.\n * @param params.ctx - The context object required by the API methods.\n * @returns A fluent interface for the given API.\n */\nexport function fluent<T extends Record<string, any>>({\n  api,\n  chain = [],\n  ctx,\n}: {\n  api: T;\n  chain?: StringChain | ApiCall[];\n  ctx: RequiredContext<T>;\n}): Fluent<T> {\n  const boundApi = bindConfigToApi(api, ctx || {});\n  const jsonChain =\n    typeof chain === \"string\" ? stringToChain(boundApi, chain) : chain;\n  const path = jsonChain.length\n    ? jsonChain.slice(-1)[0].method.split(\".\").slice(0, -1)\n    : [];\n  const parsedChain = chain ? initChain(jsonChain, boundApi, ctx) : [];\n  return createProxy(boundApi, parsedChain, path, ctx || {}) as Fluent<T>;\n}\n"],"mappings":"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","names":[]}