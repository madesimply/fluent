{"version":3,"sources":["../src/fluent.ts"],"sourcesContent":["type AddApiKeys<T, U> = {\n  [K in keyof U]: U[K] extends (...args: infer P) => any\n    ? P extends [infer Ctx, ...infer Rest]\n      ? (...args: Rest) => AddConfigPropAndReturn<U, U>\n      : AddConfigPropAndReturn<U, U>\n    : AddConfigPropAndReturn<U[K], U>;\n};\n\nexport type AddConfigPropAndReturn<T, U> = T extends (...args: any[]) => any\n  ? Parameters<T> extends [infer Ctx, ...infer Rest]\n    ? ((...args: Rest) => AddConfigPropAndReturn<U, U>) & AddApiKeys<T, U>\n    : AddConfigPropAndReturn<U, U> & AddApiKeys<T, U>\n  : {\n      [P in keyof T]: T[P] extends (...args: any[]) => any\n        ? Parameters<T[P]> extends [infer Ctx, ...infer Rest]\n          ? ((...args: Rest) => AddConfigPropAndReturn<U, U>) & AddApiKeys<T, U>\n          : AddConfigPropAndReturn<U, U> & AddApiKeys<T, U> & T[P]\n        : AddConfigPropAndReturn<T[P], U>;\n    } & AddApiKeys<T, U>;\n\nexport type FluentApi<V, U> = AddConfigPropAndReturn<V, U>;\n\nexport type CombinedFluentApi<T> = {\n  [K in keyof T]: FluentApi<T[K], T>;\n};\n\nexport type ApiCall = { method: string; args?: any[] };\n\nexport function fluent<T extends Record<string, any>>(api: T): CombinedFluentApi<T> {\n  let chain: any = null;\n\n  const createProxy = (parentCalls: ApiCall[] = [], path: string[] = []): any => {\n    const calls = [...parentCalls];\n\n    const runMethod = (ctx: any, call: ApiCall) => {\n      const { method: path, args } = call;\n      const method: any = path.split(\".\").reduce((acc, key) => acc[key], api);\n      return method(ctx, ...(args || []));\n    };\n\n    const runPromises = async (ctx: any, firstResult: Promise<any>, calls: ApiCall[]) => {\n      ctx = await firstResult;\n      for (const call of calls) {\n        const result = runMethod(ctx, call);\n        if (result instanceof Promise) {\n          await result;\n        }\n        ctx = result;\n      }\n      return ctx;\n    };\n\n    const run = (ctx: any) => {\n      for (const call of calls) {\n        const result = runMethod(ctx, call);\n        if (result instanceof Promise) {\n          const remaining = calls.slice(calls.indexOf(call) + 1);\n          return runPromises(ctx, result, remaining);\n        }\n        ctx = result;\n      }\n      return ctx;\n    };\n\n    const handler: ProxyHandler<any> = {\n      get(_, prop: string | symbol): any {\n        if (prop === \"run\") return run;\n        if (prop === \"toJSON\") return () => calls;\n        if (typeof prop !== \"string\") return undefined;\n\n        const baseTarget = prop in api ? api[prop] : undefined;\n        const newPath = baseTarget ? [prop] : [...path, prop];\n        const fullPath = newPath.join(\".\");\n        const target = baseTarget || newPath.reduce((acc, key) => acc[key], api);\n\n        if (typeof target === \"object\") {\n          return createProxy(calls, newPath);\n        }\n\n        if (typeof target === \"function\") {\n          const func = target as Function;\n          if (func.length <= 1) {\n            return createProxy([...calls, { method: fullPath }], path);\n          }\n          return (...args: any[]) => {\n            return createProxy([...calls, { method: fullPath, args }], path);\n          };\n        }\n\n        return undefined;\n      },\n    };\n\n    return new Proxy(() => {}, handler);\n  };\n\n  chain = createProxy() as CombinedFluentApi<T>;\n  return chain;\n}\n\nexport const toChain = (op: string, fluent: any): any => {\n  const config: ApiCall[] =\n    typeof op === \"string\" ? JSON.parse(op) : JSON.parse(JSON.stringify(op));\n\n  let current = fluent;\n  for (const { method, args } of config) {\n    const methods = method.split(\".\");\n    for (const m of methods) {\n      if (methods.indexOf(m) === methods.length - 1 && args?.length) {\n        current = current[m](...(args || []));\n        continue;\n      }\n      current = current[m];\n    }\n  }\n\n  return current;\n};\n"],"mappings":";AA4BO,SAAS,OAAsC,KAA8B;AAClF,MAAI,QAAa;AAEjB,QAAM,cAAc,CAAC,cAAyB,CAAC,GAAG,OAAiB,CAAC,MAAW;AAC7E,UAAM,QAAQ,CAAC,GAAG,WAAW;AAE7B,UAAM,YAAY,CAAC,KAAU,SAAkB;AAC7C,YAAM,EAAE,QAAQA,OAAM,KAAK,IAAI;AAC/B,YAAM,SAAcA,MAAK,MAAM,GAAG,EAAE,OAAO,CAAC,KAAK,QAAQ,IAAI,GAAG,GAAG,GAAG;AACtE,aAAO,OAAO,KAAK,GAAI,QAAQ,CAAC,CAAE;AAAA,IACpC;AAEA,UAAM,cAAc,OAAO,KAAU,aAA2BC,WAAqB;AACnF,YAAM,MAAM;AACZ,iBAAW,QAAQA,QAAO;AACxB,cAAM,SAAS,UAAU,KAAK,IAAI;AAClC,YAAI,kBAAkB,SAAS;AAC7B,gBAAM;AAAA,QACR;AACA,cAAM;AAAA,MACR;AACA,aAAO;AAAA,IACT;AAEA,UAAM,MAAM,CAAC,QAAa;AACxB,iBAAW,QAAQ,OAAO;AACxB,cAAM,SAAS,UAAU,KAAK,IAAI;AAClC,YAAI,kBAAkB,SAAS;AAC7B,gBAAM,YAAY,MAAM,MAAM,MAAM,QAAQ,IAAI,IAAI,CAAC;AACrD,iBAAO,YAAY,KAAK,QAAQ,SAAS;AAAA,QAC3C;AACA,cAAM;AAAA,MACR;AACA,aAAO;AAAA,IACT;AAEA,UAAM,UAA6B;AAAA,MACjC,IAAI,GAAG,MAA4B;AACjC,YAAI,SAAS,MAAO,QAAO;AAC3B,YAAI,SAAS,SAAU,QAAO,MAAM;AACpC,YAAI,OAAO,SAAS,SAAU,QAAO;AAErC,cAAM,aAAa,QAAQ,MAAM,IAAI,IAAI,IAAI;AAC7C,cAAM,UAAU,aAAa,CAAC,IAAI,IAAI,CAAC,GAAG,MAAM,IAAI;AACpD,cAAM,WAAW,QAAQ,KAAK,GAAG;AACjC,cAAM,SAAS,cAAc,QAAQ,OAAO,CAAC,KAAK,QAAQ,IAAI,GAAG,GAAG,GAAG;AAEvE,YAAI,OAAO,WAAW,UAAU;AAC9B,iBAAO,YAAY,OAAO,OAAO;AAAA,QACnC;AAEA,YAAI,OAAO,WAAW,YAAY;AAChC,gBAAM,OAAO;AACb,cAAI,KAAK,UAAU,GAAG;AACpB,mBAAO,YAAY,CAAC,GAAG,OAAO,EAAE,QAAQ,SAAS,CAAC,GAAG,IAAI;AAAA,UAC3D;AACA,iBAAO,IAAI,SAAgB;AACzB,mBAAO,YAAY,CAAC,GAAG,OAAO,EAAE,QAAQ,UAAU,KAAK,CAAC,GAAG,IAAI;AAAA,UACjE;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO,IAAI,MAAM,MAAM;AAAA,IAAC,GAAG,OAAO;AAAA,EACpC;AAEA,UAAQ,YAAY;AACpB,SAAO;AACT;AAEO,IAAM,UAAU,CAAC,IAAYC,YAAqB;AACvD,QAAM,SACJ,OAAO,OAAO,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,MAAM,KAAK,UAAU,EAAE,CAAC;AAEzE,MAAI,UAAUA;AACd,aAAW,EAAE,QAAQ,KAAK,KAAK,QAAQ;AACrC,UAAM,UAAU,OAAO,MAAM,GAAG;AAChC,eAAW,KAAK,SAAS;AACvB,UAAI,QAAQ,QAAQ,CAAC,MAAM,QAAQ,SAAS,MAAK,6BAAM,SAAQ;AAC7D,kBAAU,QAAQ,CAAC,EAAE,GAAI,QAAQ,CAAC,CAAE;AACpC;AAAA,MACF;AACA,gBAAU,QAAQ,CAAC;AAAA,IACrB;AAAA,EACF;AAEA,SAAO;AACT;","names":["path","calls","fluent"]}