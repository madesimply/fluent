{"version":3,"sources":["../src/fluent.ts"],"sourcesContent":["type AddApiKeys<T, U> = {\n  [K in keyof U]: U[K] extends (...args: infer P) => any\n    ? P extends [infer Ctx, ...infer Rest]\n      ? (...args: Rest) => AddConfigPropAndReturn<U, U>\n      : AddConfigPropAndReturn<U, U>\n    : AddConfigPropAndReturn<U[K], U>;\n};\n\nexport type AddConfigPropAndReturn<T, U> = T extends (...args: any[]) => any\n  ? Parameters<T> extends [infer Ctx, ...infer Rest]\n    ? ((...args: Rest) => AddConfigPropAndReturn<U, U>) & AddApiKeys<T, U>\n    : AddConfigPropAndReturn<U, U> & AddApiKeys<T, U>\n  : {\n      [P in keyof T]: T[P] extends (...args: any[]) => any\n        ? Parameters<T[P]> extends [infer Ctx, ...infer Rest]\n          ? ((...args: Rest) => AddConfigPropAndReturn<U, U>) & AddApiKeys<T, U>\n          : AddConfigPropAndReturn<U, U> & AddApiKeys<T, U> & T[P]\n        : AddConfigPropAndReturn<T[P], U>;\n    } & AddApiKeys<T, U>;\n\nexport type FluentApi<V, U> = AddConfigPropAndReturn<V, U>;\n\nexport type CombinedFluentApi<T> = {\n  [K in keyof T]: FluentApi<T[K], T>;\n};\n\nexport type ApiCall = { method: string; args?: any[] };\n\nexport function fluent<T extends Record<string, any>>(\n  apiStructure: T\n): CombinedFluentApi<T> {\n  const createProxy = (\n    parentCalls: ApiCall[] = [],\n    path: string[] = []\n  ): any => {\n    const calls = [...parentCalls];\n\n    const handler: ProxyHandler<any> = {\n      get(_, prop: string | symbol): any {\n        if (prop === \"toJSON\") return () => calls;\n        if (typeof prop !== \"string\") return undefined;\n\n        const baseTarget =\n          prop in apiStructure ? apiStructure[prop] : undefined;\n        const newPath = baseTarget ? [prop] : [...path, prop];\n        const fullPath = newPath.join(\".\");\n        const target =\n          baseTarget || newPath.reduce((acc, key) => acc[key], apiStructure);\n\n        if (typeof target === \"object\") {\n          return createProxy(calls, newPath);\n        }\n\n        if (typeof target === \"function\") {\n          const func = target as Function;\n          if (func.length <= 1) {\n            return createProxy([...calls, { method: fullPath }], path);\n          }\n          return (...args: any[]) => {\n            return createProxy([...calls, { method: fullPath, args }], path);\n          };\n        }\n\n        return undefined;\n      },\n    };\n\n    return new Proxy(() => {}, handler);\n  };\n\n  return createProxy() as CombinedFluentApi<T>;\n}\n\ntype Ctx = any;\n\nexport const run = async ({\n  op,\n  ctx,\n  api,\n}: {\n  op: any;\n  ctx: Ctx;\n  api: any;\n}): Promise<any> => {\n  const config =\n    typeof op === \"string\" ? JSON.parse(op) : JSON.parse(JSON.stringify(op));\n\n  ctx = ctx as Ctx;\n\n  const runHelper = async (op: any) => {\n    return await run({ op, ctx, api });\n  };\n\n  const executeOperation = async (item: any) => {\n    const { method: path, args = [] } = item;\n    const splitPath = path.split(\".\");\n    const method = splitPath.reduce((acc, key) => acc[key], api);\n    return method({ ctx, run: runHelper, api }, ...args);\n  };\n\n  for (let i = 0; i < config.length; i++) {\n    await executeOperation(config[i]);\n  }\n\n  return ctx;\n};\n\nexport const parseOp = (op: string, fluent: any): any => {\n  const config: ApiCall[] = typeof op === 'string' ? JSON.parse(op) : op;\n\n  let current = fluent;\n  for (const { method, args } of config) {\n    const methods = method.split(\".\");\n    for (const m of methods) {\n      if (methods.indexOf(m) === methods.length - 1) {\n        current = current[m](...(args || []));\n        continue;\n      }\n      current = current[m];\n    }\n  }\n  return current;\n};\n"],"mappings":";AA4BO,SAAS,OACd,cACsB;AACtB,QAAM,cAAc,CAClB,cAAyB,CAAC,GAC1B,OAAiB,CAAC,MACV;AACR,UAAM,QAAQ,CAAC,GAAG,WAAW;AAE7B,UAAM,UAA6B;AAAA,MACjC,IAAI,GAAG,MAA4B;AACjC,YAAI,SAAS,SAAU,QAAO,MAAM;AACpC,YAAI,OAAO,SAAS,SAAU,QAAO;AAErC,cAAM,aACJ,QAAQ,eAAe,aAAa,IAAI,IAAI;AAC9C,cAAM,UAAU,aAAa,CAAC,IAAI,IAAI,CAAC,GAAG,MAAM,IAAI;AACpD,cAAM,WAAW,QAAQ,KAAK,GAAG;AACjC,cAAM,SACJ,cAAc,QAAQ,OAAO,CAAC,KAAK,QAAQ,IAAI,GAAG,GAAG,YAAY;AAEnE,YAAI,OAAO,WAAW,UAAU;AAC9B,iBAAO,YAAY,OAAO,OAAO;AAAA,QACnC;AAEA,YAAI,OAAO,WAAW,YAAY;AAChC,gBAAM,OAAO;AACb,cAAI,KAAK,UAAU,GAAG;AACpB,mBAAO,YAAY,CAAC,GAAG,OAAO,EAAE,QAAQ,SAAS,CAAC,GAAG,IAAI;AAAA,UAC3D;AACA,iBAAO,IAAI,SAAgB;AACzB,mBAAO,YAAY,CAAC,GAAG,OAAO,EAAE,QAAQ,UAAU,KAAK,CAAC,GAAG,IAAI;AAAA,UACjE;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO,IAAI,MAAM,MAAM;AAAA,IAAC,GAAG,OAAO;AAAA,EACpC;AAEA,SAAO,YAAY;AACrB;AAIO,IAAM,MAAM,OAAO;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AACF,MAIoB;AAClB,QAAM,SACJ,OAAO,OAAO,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,MAAM,KAAK,UAAU,EAAE,CAAC;AAEzE,QAAM;AAEN,QAAM,YAAY,OAAOA,QAAY;AACnC,WAAO,MAAM,IAAI,EAAE,IAAAA,KAAI,KAAK,IAAI,CAAC;AAAA,EACnC;AAEA,QAAM,mBAAmB,OAAO,SAAc;AAC5C,UAAM,EAAE,QAAQ,MAAM,OAAO,CAAC,EAAE,IAAI;AACpC,UAAM,YAAY,KAAK,MAAM,GAAG;AAChC,UAAM,SAAS,UAAU,OAAO,CAAC,KAAK,QAAQ,IAAI,GAAG,GAAG,GAAG;AAC3D,WAAO,OAAO,EAAE,KAAK,KAAK,WAAW,IAAI,GAAG,GAAG,IAAI;AAAA,EACrD;AAEA,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,iBAAiB,OAAO,CAAC,CAAC;AAAA,EAClC;AAEA,SAAO;AACT;AAEO,IAAM,UAAU,CAAC,IAAYC,YAAqB;AACvD,QAAM,SAAoB,OAAO,OAAO,WAAW,KAAK,MAAM,EAAE,IAAI;AAEpE,MAAI,UAAUA;AACd,aAAW,EAAE,QAAQ,KAAK,KAAK,QAAQ;AACrC,UAAM,UAAU,OAAO,MAAM,GAAG;AAChC,eAAW,KAAK,SAAS;AACvB,UAAI,QAAQ,QAAQ,CAAC,MAAM,QAAQ,SAAS,GAAG;AAC7C,kBAAU,QAAQ,CAAC,EAAE,GAAI,QAAQ,CAAC,CAAE;AACpC;AAAA,MACF;AACA,gBAAU,QAAQ,CAAC;AAAA,IACrB;AAAA,EACF;AACA,SAAO;AACT;","names":["op","fluent"]}