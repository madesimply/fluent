function h(n,e,r){let{method:t,args:o}=r;return t.split(".").reduce((c,u)=>c[u],n)(e,...o||[])}async function x(n,e,r,t){await r,e=r===void 0?e:r;for(let o of t){let i=h(n,e,o);i instanceof Promise&&await i,e=i===void 0?e:i}return e}function b(n,e,r){let t=n.slice(r+1),o=JSON.stringify(e),i=t.findIndex(s=>JSON.stringify(s)===o);return i>-1?i:n.slice(0,r+1).findIndex(({goto:s,...f})=>JSON.stringify(f)===o)}function m(n,e,r,t){let o=[...e],i=(u,s=0)=>{var y;let f=-1;for(let a=s;a<o.length;a++){let l=o[a];if(l.goto&&l.goto.args){let d=b(o,l.goto.args[0],a);d>-1&&(f=d)}let g=h(n,u,l);if(g instanceof Promise){let d=o.slice(o.indexOf(l)+1);return x(n,u,g,d)}u=g===void 0?u:g,f>-1}if(f>-1){if((y=t==null?void 0:t.fluent)!=null&&y.blocking)return i(u,f);setTimeout(()=>i(u,f),0)}return u},c={get(u,s){if(s==="run")return i;if(s==="toJSON")return()=>o;if(s==="goto")return g=>{let d={method:"goto",args:JSON.parse(JSON.stringify(g))};return o[o.length-1].goto=d,m(n,[...o],r,t)};if(s==="toString")return()=>R(o);if(typeof s!="string")return;let y=(s in n?n[s]:void 0)?[s]:[...r,s],a=y.join("."),l=y.reduce((g,d)=>g[d],n);if(typeof l=="object"&&l!==null)return m(n,o,y,t);if(typeof l=="function")return l.length<=1?m(n,[...o,{method:a}],r,t):(...d)=>m(n,[...o,{method:a,args:d}],r,t)}};return new Proxy(()=>{},c)}function T(n,e){let r={};for(let t in n)typeof n[t]=="function"?r[t]=n[t].bind(e):typeof n[t]=="object"&&n[t]!==null?r[t]=T(n[t],e):r[t]=n[t];return r}function p(n,e,r){return n.map(t=>(t.args&&(t.args=t.args.map(o=>C(o,e,r))),t))}function C(n,e,r){let t=Array.isArray(n),o=!t&&typeof n=="object"&&n!==null;if(t)return n.every(i=>"method"in i)?S({api:e,chain:n,ctx:r}):n.map(i=>C(i,e,r));if(o){for(let i in n)n[i]=C(n[i],e,r);return n}return n}function A(n,e){let[r,...t]=n.split("("),i=t.join("(").replace(/\)$/,"").split(",").map(c=>c.split("(")[0].trim().split(".").reduce((f,y)=>f&&f[y],e)?A(c.trim(),e):c.trim());return[{method:r,args:i}]}function R(n){return n.map(e=>{var t;let r=(t=e.args)!=null&&t.length?`(${e.args.join(", ")})`:"";return`${e.method}${r}`}).join(".")}function S({api:n,chain:e=[],ctx:r}){let t=T(n,r||{}),o=typeof e=="string"?A(e,t):e,i=o.length?o.slice(-1)[0].method.split(".").slice(0,-1):[],c=e?p(o,t,r):[];return m(t,c,i,r||{})}export{S as fluent,p as initChain};
//# sourceMappingURL=index.js.map