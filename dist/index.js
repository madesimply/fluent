function T(n,r,t){let{method:e,args:o}=t;return e.split(".").reduce((a,u)=>a[u],n)(r,...o||[])}async function x(n,r,t,e){r=await t;for(let o of e){let i=T(n,r,o);i instanceof Promise&&await i,r=i===void 0?r:i}return r}function h(n,r,t){let e=n.slice(t+1),o=JSON.stringify(r),i=e.findIndex(s=>JSON.stringify(s)===o);return i>-1?i:n.slice(0,t+1).findIndex(({goto:s,...d})=>JSON.stringify(d)===o)}function m(n,r=[],t=[],e){let o=[...r],i=(u,s=0)=>{var g;let d=-1;for(let y=s;y<o.length;y++){let f=o[y];if(f.goto&&f.goto.args){let l=h(o,f.goto.args[0],y);l>-1&&(d=l)}let c=T(n,u,f);if(c instanceof Promise){let l=o.slice(o.indexOf(f)+1);return x(n,u,c,l)}u=c===void 0?u:c,d>-1}if(d>-1){if((g=e==null?void 0:e.fluent)!=null&&g.blocking)return i(u,d);setTimeout(()=>i(u,d),0)}return u},a={get(u,s){if(s==="run")return i;if(s==="toJSON")return()=>o;if(s==="goto")return c=>{let l={method:"goto",args:JSON.parse(JSON.stringify(c))};return o[o.length-1].goto=l,m(n,[...o],t,e)};if(typeof s!="string")return;let g=(s in n?n[s]:void 0)?[s]:[...t,s],y=g.join("."),f=g.reduce((c,l)=>c[l],n);if(typeof f=="object"&&f!==null)return m(n,o,g,e);if(typeof f=="function")return f.length<=1?m(n,[...o,{method:y}],t,e):(...l)=>m(n,[...o,{method:y,args:l}],t,e)}};return new Proxy(()=>{},a)}function A(n,r){let t={};for(let e in n)typeof n[e]=="function"?t[e]=n[e].bind(r):typeof n[e]=="object"&&n[e]!==null?t[e]=A(n[e],r):t[e]=n[e];return t}function b(n,r,t){return n.map(e=>(e.args&&(e.args=e.args.map(o=>C(o,r,t))),e))}function C(n,r,t){let e=Array.isArray(n),o=!e&&typeof n=="object"&&n!==null;if(e)return n.every(i=>"method"in i)?R({api:r,chain:n,ctx:t}):n.map(i=>C(i,r,t));if(o){for(let i in n)n[i]=C(n[i],r,t);return n}return n}function R({api:n,chain:r=[],ctx:t}){let e=r.length?r.slice(-1)[0].method.split(".").slice(0,-1):[],o=A(n,t||{}),i=r?b(r,n,t):[];return m(o,i,e,t||{})}export{R as fluent,b as initChain};
//# sourceMappingURL=index.js.map