{"version":3,"sources":["../src/index.ts","../src/fluent.ts"],"sourcesContent":["export * from \"./fluent\";\nexport * from \"./types\";","import { ApiCall, Ctx, Fluent, RequiredContext, StringChain } from \"./types\";\n\n/**\n * Executes a method from the API with the provided context and arguments.\n * @param api - The API object containing the methods.\n * @param ctx - The context object passed to the method.\n * @param call - An object containing the method name and arguments.\n * @returns The result of the method execution.\n */\nfunction runMethod(api: Record<string, any>, ctx: any, call: ApiCall) {\n  const { method, args } = call;\n  const methodFunc: any = method.split(\".\").reduce((acc, key) => acc[key], api);\n  return methodFunc(ctx, ...(args || []));\n}\n\n/**\n * Executes a sequence of API calls, handling promises for asynchronous operations.\n * @param api - The API object containing the methods.\n * @param data - The initial context object.\n * @param firstResult - The result of the first API call.\n * @param calls - An array of subsequent API calls to execute.\n * @returns A promise that resolves to the final context after all calls are executed.\n */\nasync function runPromises(\n  api: Record<string, any>,\n  data: any,\n  firstResult: Promise<any>,\n  calls: ApiCall[]\n) {\n  await firstResult;\n  data = firstResult === undefined ? data : firstResult;\n  for (const call of calls) {\n    const result = runMethod(api, data, call);\n    if (result instanceof Promise) {\n      await result;\n    }\n    data = result === undefined ? data : result;\n  }\n  return data;\n}\n\n/**\n * Finds the index of the next API call in the chain that matches the specified call.\n * @param calls - The list of API calls.\n * @param call - The API call to find in the list.\n * @param current - The current index in the list of API calls.\n * @returns The index of the matching call, or -1 if not found.\n */\nfunction callIndex(calls: ApiCall[], call: ApiCall, current: number) {\n  const remaining = calls.slice(current + 1);\n  const gotoCall = JSON.stringify(call);\n  const nextIndex = remaining.findIndex((c) => JSON.stringify(c) === gotoCall);\n  if (nextIndex > -1) {\n    return nextIndex;\n  }\n  const start = calls.slice(0, current + 1);\n  const prevIndex = start.findIndex(\n    ({ goto, ...c }) => JSON.stringify(c) === gotoCall\n  );\n  return prevIndex;\n}\n\n/**\n * Creates a proxy object that allows fluent method chaining for the given API.\n * @param api - The API object containing methods and properties.\n * @param parentCalls - The list of previous API calls.\n * @param path - The current path of method calls.\n * @param ctx - The context configuration object.\n * @returns A proxy object that supports method chaining.\n */\nfunction createProxy<T extends Record<string, any>>(\n  api: T,\n  parentCalls: ApiCall[],\n  path: string[],\n  ctx: Ctx\n): any {\n  const calls = [...parentCalls];\n\n  const run = (data: any, from = 0) => {\n    let goto = -1;\n    for (let i = from; i < calls.length; i++) {\n      let call = calls[i];\n      if (call.goto && call.goto.args) {\n        const index = callIndex(calls, call.goto.args[0], i);\n        if (index > -1) goto = index;\n      }\n      const result = runMethod(api, data, call);\n      if (result instanceof Promise) {\n        const remaining = calls.slice(calls.indexOf(call) + 1);\n        return runPromises(api, data, result, remaining);\n      }\n      data = result === undefined ? data : result;\n      if (goto > -1) continue;\n    }\n    if (goto > -1) {\n      if (ctx?.fluent?.blocking) {\n        return run(data, goto);\n      }\n      {\n        setTimeout(() => run(data, goto), 0);\n      }\n    }\n    return data;\n  };\n\n  const handler: ProxyHandler<any> = {\n    get(_, prop: string | symbol): any {\n      if (prop === \"run\") return run;\n      if (prop === \"toJSON\") return () => calls;\n      if (prop === \"goto\")\n        return (call: ApiCall) => {\n          const goto = {\n            method: \"goto\",\n            args: JSON.parse(JSON.stringify(call)),\n          };\n          calls[calls.length - 1].goto = goto;\n          return createProxy(api, [...calls], path, ctx);\n        };\n      if (prop === \"toString\") return () => chainToString(calls);\n\n      if (typeof prop !== \"string\") return undefined;\n\n      const baseTarget = prop in api ? api[prop] : undefined;\n      const newPath = baseTarget ? [prop] : [...path, prop];\n      const fullPath = newPath.join(\".\");\n      const targetValue = newPath.reduce((acc, key) => acc[key], api);\n\n      if (typeof targetValue === \"object\" && targetValue !== null) {\n        return createProxy(api, calls, newPath, ctx);\n      }\n\n      if (typeof targetValue === \"function\") {\n        const func = targetValue as Function;\n        if (func.length <= 1) {\n          return createProxy(api, [...calls, { method: fullPath }], path, ctx);\n        }\n        return (...args: any[]) => {\n          return createProxy(\n            api,\n            [...calls, { method: fullPath, args }],\n            path,\n            ctx\n          );\n        };\n      }\n\n      return undefined;\n    },\n  };\n\n  return new Proxy(() => {}, handler);\n}\n\n/**\n * Binds a context object to all functions within an API, allowing them to use the context as `this`.\n * @param api - The API object containing methods and properties.\n * @param ctx - The context object to bind to the API functions.\n * @returns The API object with context-bound functions.\n */\nfunction bindConfigToApi<T extends Record<string, any>>(api: T, ctx: Ctx): T {\n  const boundApi = {} as T;\n\n  for (const key in api) {\n    if (typeof api[key] === \"function\") {\n      // Bind the configuration to the function\n      boundApi[key] = api[key].bind(ctx);\n    } else if (typeof api[key] === \"object\" && api[key] !== null) {\n      // Recursively bind the configuration for nested objects\n      boundApi[key] = bindConfigToApi(api[key], ctx);\n    } else {\n      boundApi[key] = api[key];\n    }\n  }\n\n  return boundApi;\n}\n\n/**\n * Traverses the chain and its arguments. Recursively processes each element, converting serialized chains back into fluent interfaces,\n * and handling primitives, objects, and nested structures as needed.\n * @param chain - The chain to traverse.\n * @param api - The API object containing methods and properties.\n * @param ctx - The context object required by the API methods.\n * @returns The chain with serialized chains and nested structures converted into their appropriate forms.\n */\nexport function initChain<T extends Record<string, any>>(\n  chain: ApiCall[],\n  api: T,\n  ctx: RequiredContext<T>\n): ApiCall[] {\n  return chain.map((call) => {\n    if (call.args) {\n      call.args = call.args.map((arg) => processArgument(arg, api, ctx));\n    }\n    return call;\n  });\n}\n\n/**\n * Processes individual arguments within an API call, handling arrays, objects, and primitives.\n * @param arg - The argument to process.\n * @param api - The API object containing methods and properties.\n * @param ctx - The context object required by the API methods.\n * @returns The processed argument, potentially converted back into a fluent interface.\n */\nfunction processArgument<T extends Record<string, any>>(\n  arg: any,\n  api: T,\n  ctx: RequiredContext<T>\n): any {\n  const isArray = Array.isArray(arg);\n  const isObject = !isArray && typeof arg === \"object\" && arg !== null;\n\n  if (isArray) {\n    // Handle arrays that may contain serialized chains or other arrays\n    if (arg.every((a) => \"method\" in a)) {\n      return fluent({ api, chain: arg, ctx });\n    }\n    return arg.map((item) => processArgument(item, api, ctx)); // Recurse for nested arrays\n  }\n\n  if (isObject) {\n    // Handle objects by recursively processing each property\n    for (const key in arg) {\n      arg[key] = processArgument(arg[key], api, ctx);\n    }\n    return arg;\n  }\n\n  // Return primitive values as-is\n  return arg;\n}\n\n/**\n * Parses a method chaining string into an array of API calls.\n * @param chainString - The string representing the method chain.\n * @param api - The API object containing methods and properties.\n * @returns An array of API calls parsed from the string.\n */\nfunction stringToChain<T extends Record<string, any>>(\n  chainString: string,\n  api: T\n): ApiCall[] {\n  const regex = /(\\w+)(?:\\(([^)]*)\\))?/g;\n  const calls: ApiCall[] = [];\n  let namespace: T = api;\n  let currentPath: string[] = [];\n  let lastCallArgs: any[] = [];\n\n  while (true) {\n    const match = regex.exec(chainString);\n    if (!match) break;\n\n    const [, part, args] = match;\n\n    if (!namespace[part] && api[part]) {\n      namespace = api;\n      currentPath = [];\n    }\n\n    if (typeof namespace[part] === \"function\") {\n      const methodName = currentPath.length\n        ? `${currentPath.join(\".\")}.${part}`\n        : part;\n\n      // Parse the arguments, handling nested chains\n      const parsedArgs = args\n        ? args.split(\",\").map((arg) => parseArgument(arg.trim(), api))\n        : [];\n\n      if (lastCallArgs.length > 0) {\n        // Add the previous call to the current arguments\n        lastCallArgs.push({\n          method: methodName,\n          args: parsedArgs,\n        });\n      } else {\n        calls.push({\n          method: methodName,\n          args: parsedArgs,\n        });\n      }\n\n      // Update lastCallArgs if the method has nested calls\n      if (parsedArgs.some(arg => Array.isArray(arg))) {\n        lastCallArgs = [];\n      } else {\n        lastCallArgs = parsedArgs;\n      }\n    } else if (typeof namespace[part] === \"object\") {\n      namespace = namespace[part];\n      currentPath.push(part);\n    }\n\n    if (!chainString.slice(regex.lastIndex).trim().startsWith(\".\")) {\n      namespace = api;\n      currentPath = [];\n      lastCallArgs = [];\n    }\n  }\n\n  return calls;\n}\n\nfunction parseArgument<T extends Record<string, any>>(\n  arg: string,\n  api: T\n): any {\n  // Check if the argument is a chain (not wrapped in quotes)\n  const isChain = !/^['\"].*['\"]$/.test(arg);\n  if (isChain) {\n    return stringToChain(arg, api);\n  }\n\n  // Otherwise, return the argument as a literal value\n  return arg;\n}\n\n/**\n * Converts an array of API calls back into a method chaining string.\n * @param calls - An array of API calls.\n * @returns The method chaining string.\n */\nfunction chainToString(calls: ApiCall[]): string {\n  return calls\n    .map((call) => {\n      const args = call.args?.length ? `(${call.args.join(\", \")})` : \"\";\n      return `${call.method}${args}`;\n    })\n    .join(\".\");\n}\n\n/**\n * Creates a fluent interface for the given API, allowing for method chaining and context management.\n * @param params - The parameters for creating the fluent interface.\n * @param params.api - The API object containing methods and properties.\n * @param params.chain - The initial chain of API calls.\n * @param params.ctx - The context object required by the API methods.\n * @returns A fluent interface for the given API.\n */\nexport function fluent<T extends Record<string, any>>({\n  api,\n  chain = [],\n  ctx,\n}: {\n  api: T;\n  chain?: StringChain | ApiCall[];\n  ctx: RequiredContext<T>;\n}): Fluent<T> {\n  const boundApi = bindConfigToApi(api, ctx || {});\n  const jsonChain =\n    typeof chain === \"string\" ? stringToChain(chain, boundApi) : chain;\n  const path = jsonChain.length\n    ? jsonChain.slice(-1)[0].method.split(\".\").slice(0, -1)\n    : [];\n  const parsedChain = chain ? initChain(jsonChain, boundApi, ctx) : [];\n  return createProxy(boundApi, parsedChain, path, ctx || {}) as Fluent<T>;\n}\n"],"mappings":"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","names":["src_exports","__export","fluent","initChain","__toCommonJS","runMethod","api","ctx","call","method","args","acc","key","runPromises","data","firstResult","calls","result","callIndex","current","remaining","gotoCall","nextIndex","c","goto","createProxy","parentCalls","path","run","from","_a","i","index","handler","_","prop","chainToString","newPath","fullPath","targetValue","bindConfigToApi","boundApi","initChain","chain","arg","processArgument","isArray","isObject","a","fluent","item","stringToChain","chainString","regex","namespace","currentPath","lastCallArgs","match","part","methodName","parsedArgs","parseArgument","jsonChain","parsedChain"]}