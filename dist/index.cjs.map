{"version":3,"sources":["../src/fluent.ts"],"names":["isObject","value","isChainItem","item","isFluent","processArgument","arg","api","ctx","fluent","a","processedArg","key","chainItemToString","args","createProxy","rootApi","currentApi","currentChain","path","options","target","data","runChain","fluentProxy","prop","nextApi","nextPath","method","constArgs","newChain","bindApiToContext","boundApi","parseInitialChain","chain","jsonChain","initialData","index","isAsync","processNextItem","obj","result","resolvedData","runAsyncChain","config","initialChain","parsedChain"],"mappings":"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","file":"index.cjs","sourcesContent":["// fluent.ts\nimport {\n  Chain,\n  ChainItem,\n  Fluent,\n  FluentConfig,\n  FluentStructure,\n  ApiContext,\n  HasRequiredProperties,\n  FluentOptions,\n  SetImmediateFunction,\n} from './types';\n\n// Utility functions\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction isChainItem(item: unknown): item is Chain[number] {\n  return (\n    typeof item === 'object' &&\n    item !== null &&\n    'method' in item &&\n    typeof (item as any).method === 'string' &&\n    'args' in item &&\n    Array.isArray((item as any).args)\n  );\n}\n\nfunction isFluent(value: unknown): value is FluentStructure {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'chain' in value &&\n    Array.isArray((value as any).chain)\n  );\n}\n\nfunction processArgument(arg: unknown, api: any, ctx: any): any {\n  if (isFluent(arg)) {\n    return fluent({ api, chain: arg.chain, ctx });\n  }\n  if (Array.isArray(arg)) {\n    return arg.map((item) => processArgument(item, api, ctx));\n  }\n  if (isChainItem(arg)) {\n    return {\n      ...arg,\n      args: arg.args.map(a => processArgument(a, api, ctx))\n    };\n  }\n  if (typeof arg === 'object' && arg !== null) {\n    const processedArg: Record<string, any> = {};\n    for (const key in arg) {\n      processedArg[key] = processArgument((arg as any)[key], api, ctx);\n    }\n    return processedArg;\n  }\n  return arg;\n}\n\nfunction chainItemToString(item: Chain[number]): string {\n  const args = item.args.map(arg => JSON.stringify(arg)).join(', ');\n  return `${item.method}(${args})`;\n}\n\nfunction createProxy<TRootApi, TCurrentApi, TCurrentChain extends Chain, TPath extends string>(\n  rootApi: TRootApi,\n  currentApi: TCurrentApi,\n  currentChain: TCurrentChain,\n  path: TPath,\n  options: FluentOptions\n): Fluent<TRootApi, TCurrentApi, TCurrentChain, TPath> {\n  const target: Fluent<TRootApi, TCurrentApi, TCurrentChain, TPath> = {\n    chain: currentChain,\n    run: (data: any) => runChain(rootApi, data, currentChain, options),\n    goto: (fluentProxy: FluentStructure) => {\n      if (!isFluent(fluentProxy) || fluentProxy.chain.length === 0) {\n        throw new Error(\"Goto must receive a non-empty Fluent\");\n      }\n      return createProxy(rootApi, currentApi, [...currentChain, ...fluentProxy.chain] as any, path, options);\n    },\n    toString: () => currentChain.map(chainItemToString).join('.').replace(/\\.$/, '')\n  } as Fluent<TRootApi, TCurrentApi, TCurrentChain, TPath>;\n\n  return new Proxy(target, {\n    get(target, prop: string | symbol) {\n      if (prop in target) {\n        return (target as any)[prop];\n      }\n\n      let nextApi: unknown;\n      let nextPath: string;\n\n      if (isObject(currentApi) && prop in currentApi) {\n        nextApi = (currentApi as any)[prop];\n        nextPath = `${path}${path ? '.' : ''}${prop as string}`;\n      } else if (isObject(rootApi) && prop in rootApi) {\n        nextApi = (rootApi as any)[prop];\n        nextPath = prop as string;\n      } else {\n        return undefined;\n      }\n\n      if (typeof nextApi === 'function') {\n        return (...args: any[]) => {\n          const method = nextPath;\n          const constArgs = { args } as const;\n          const newChain = [\n            ...currentChain,\n            { \n              method, \n              args: constArgs.args,\n              data: {} as any, // Placeholder for data type\n              return: {} as any, // Placeholder for return type\n            }\n          ];\n          return createProxy(rootApi, currentApi, newChain, path, options);\n        };\n      }\n\n      if (isObject(nextApi)) {\n        return createProxy(rootApi, nextApi as any, currentChain, nextPath, options);\n      }\n\n      return undefined;\n    }\n  });\n}\nfunction bindApiToContext<TApi, TCtx>(api: TApi, ctx: TCtx = {} as TCtx): TApi {\n  const boundApi: any = {};\n  for (const key in api) {\n    if (typeof api[key] === 'function') {\n      boundApi[key] = (api[key] as Function).bind(ctx);\n    } else if (typeof api[key] === 'object' && api[key] !== null) {\n      boundApi[key] = bindApiToContext(api[key], ctx);\n    } else {\n      boundApi[key] = api[key];\n    }\n  }\n  return boundApi as TApi;\n}\n\nfunction parseInitialChain<TApi, TCtx, T extends Chain | string | undefined>(\n  api: TApi,\n  ctx: TCtx,\n  chain: T\n): T extends string ? Chain : T extends Chain ? T : [] {\n  if (!chain) return [] as any;\n\n  let jsonChain: Chain;\n  if (typeof chain === 'string') {\n    const getChain = new Function(\"api\", \"fluent\", `\n      const root = fluent({ api });\n      const { ${Object.keys(api as object).join(\",\")} } = root;\n      const chain = ${chain};\n      return chain.chain;\n    `);\n    jsonChain = getChain(api, fluent);\n  } else {\n    jsonChain = chain as Chain;\n  }\n\n  return jsonChain.map((item) => {\n    if (isChainItem(item)) {\n      return {\n        ...item,\n        args: item.args.map((arg) => processArgument(arg, api, ctx))\n      };\n    }\n    return item;\n  }) as any;\n}\n\n// Utility function to get a cross-environment compatible setImmediate\nconst getSetImmediate = (): SetImmediateFunction => {\n  if (typeof setImmediate === 'function') {\n    return setImmediate;\n  }\n  if (typeof globalThis !== 'undefined' && typeof globalThis.setImmediate === 'function') {\n    return globalThis.setImmediate;\n  }\n  return (fn: (...args: any[]) => void, ...args: any[]) => setTimeout(fn, 0, ...args);\n};\n\n// Use the utility function to create our setImmediate\nconst setImmediate: SetImmediateFunction = getSetImmediate();\n\nfunction runChain<TApi>(api: TApi, initialData: any, chain: Chain, options: FluentOptions): any {\n  let data = initialData;\n  let index = 0;\n  let isAsync = false;\n\n  function processNextItem(): any {\n    if (index >= chain.length) {\n      return data;\n    }\n\n    const item = chain[index];\n\n    if (isChainItem(item)) {\n      const method = item.method.split('.').reduce((obj: any, key) => obj[key], api);\n      if (typeof method !== 'function') {\n        throw new Error(`Method ${item.method} not found in API`);\n      }\n\n      const result = method(data, ...item.args);\n\n      if (result instanceof Promise) {\n        return result.then(resolvedData => \n          runAsyncChain(api, resolvedData, chain.slice(index + 1), options)\n        );\n      }\n\n      data = result === undefined ? data : result;\n    }\n\n    index++;\n    return processNextItem();\n  }\n\n  const result = processNextItem();\n  return isAsync ? new Promise(resolve => setImmediate(() => resolve(result))) : result;\n}\n\nasync function runAsyncChain<TApi>(api: TApi, initialData: any, chain: Chain, options: FluentOptions): Promise<any> {\n  let data = initialData;\n  let index = 0;\n\n  while (index < chain.length) {\n    const item = chain[index];\n\n    if (isChainItem(item)) {\n      const method = item.method.split('.').reduce((obj: any, key) => obj[key], api);\n      if (typeof method !== 'function') {\n        throw new Error(`Method ${item.method} not found in API`);\n      }\n\n      const result = await method(data, ...item.args);\n      data = result === undefined ? data : result;\n    }\n\n    index++;\n  }\n\n  return data;\n}\n\nexport function fluent<TApi, TCtx extends ApiContext<TApi>, TInitialChain extends Chain = []>(\n  config: HasRequiredProperties<ApiContext<TApi>> extends true\n    ? FluentConfig<TApi, ApiContext<TApi>, TInitialChain> & { ctx: ApiContext<TApi> }\n    : FluentConfig<TApi, ApiContext<TApi>, TInitialChain>\n): Fluent<TApi, TApi, TInitialChain, \"\"> {\n  const { api, ctx, chain: initialChain } = config;\n\n  const boundApi = bindApiToContext(api, ctx);\n  const parsedChain = parseInitialChain(boundApi, ctx || {}, initialChain) as TInitialChain;\n\n  const options = ctx?.fluent || { blocking: false };\n\n  return createProxy(boundApi, boundApi, parsedChain, \"\", options);\n}\n\n// export types\n\nexport {\n  Fluent,\n  FluentConfig,\n  Chain,\n  ChainItem,\n  ApiContext,\n  FluentOptions,\n};\n"]}