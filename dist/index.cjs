var C=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var O=Object.prototype.hasOwnProperty;var F=(n,t)=>{for(var r in t)C(n,r,{get:t[r],enumerable:!0})},I=(n,t,r,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of P(t))!O.call(n,o)&&o!==r&&C(n,o,{get:()=>t[o],enumerable:!(e=R(t,o))||e.enumerable});return n};var J=n=>I(C({},"__esModule",{value:!0}),n);var j={};F(j,{fluent:()=>b,initChain:()=>h});module.exports=J(j);function A(n,t,r){let{method:e,args:o}=r;return e.split(".").reduce((a,u)=>a[u],n)(t,...o||[])}async function N(n,t,r,e){t=await r;for(let o of e){let i=A(n,t,o);i instanceof Promise&&await i,t=i===void 0?t:i}return t}function S(n,t,r){let e=n.slice(r+1),o=JSON.stringify(t),i=e.findIndex(s=>JSON.stringify(s)===o);return i>-1?i:n.slice(0,r+1).findIndex(({goto:s,...d})=>JSON.stringify(d)===o)}function m(n,t=[],r=[],e){let o=[...t],i=(u,s=0)=>{var g;let d=-1;for(let y=s;y<o.length;y++){let f=o[y];if(f.goto&&f.goto.args){let l=S(o,f.goto.args[0],y);l>-1&&(d=l)}let c=A(n,u,f);if(c instanceof Promise){let l=o.slice(o.indexOf(f)+1);return N(n,u,c,l)}u=c===void 0?u:c,d>-1}if(d>-1){if((g=e==null?void 0:e.fluent)!=null&&g.blocking)return i(u,d);setTimeout(()=>i(u,d),0)}return u},a={get(u,s){if(s==="run")return i;if(s==="toJSON")return()=>o;if(s==="goto")return c=>{let l={method:"goto",args:JSON.parse(JSON.stringify(c))};return o[o.length-1].goto=l,m(n,[...o],r,e)};if(typeof s!="string")return;let g=(s in n?n[s]:void 0)?[s]:[...r,s],y=g.join("."),f=g.reduce((c,l)=>c[l],n);if(typeof f=="object"&&f!==null)return m(n,o,g,e);if(typeof f=="function")return f.length<=1?m(n,[...o,{method:y}],r,e):(...l)=>m(n,[...o,{method:y,args:l}],r,e)}};return new Proxy(()=>{},a)}function x(n,t){let r={};for(let e in n)typeof n[e]=="function"?r[e]=n[e].bind(t):typeof n[e]=="object"&&n[e]!==null?r[e]=x(n[e],t):r[e]=n[e];return r}function h(n,t,r){return n.map(e=>(e.args&&(e.args=e.args.map(o=>T(o,t,r))),e))}function T(n,t,r){let e=Array.isArray(n),o=!e&&typeof n=="object"&&n!==null;if(e)return n.every(i=>"method"in i)?b({api:t,chain:n,ctx:r}):n.map(i=>T(i,t,r));if(o){for(let i in n)n[i]=T(n[i],t,r);return n}return n}function b({api:n,chain:t=[],ctx:r}){let e=t.length?t.slice(-1)[0].method.split(".").slice(0,-1):[],o=x(n,r||{}),i=t?h(t,n,r):[];return m(o,i,e,r||{})}0&&(module.exports={fluent,initChain});
//# sourceMappingURL=index.cjs.map