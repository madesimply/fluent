var A=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var I=Object.prototype.hasOwnProperty;var P=(n,e)=>{for(var t in e)A(n,t,{get:e[t],enumerable:!0})},j=(n,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of w(e))!I.call(n,r)&&r!==t&&A(n,r,{get:()=>e[r],enumerable:!(i=b(e,r))||i.enumerable});return n};var k=n=>j(A({},"__esModule",{value:!0}),n);var q={};P(q,{fluent:()=>m});module.exports=k(q);function p(n){return typeof n=="object"&&n!==null}function d(n){return typeof n=="object"&&n!==null&&"method"in n&&typeof n.method=="string"&&"args"in n&&Array.isArray(n.args)}function x(n){return typeof n=="object"&&n!==null&&"chain"in n&&Array.isArray(n.chain)}function h(n,e,t){if(x(n))return m({api:e,chain:n.chain,ctx:t});if(Array.isArray(n))return n.map(i=>h(i,e,t));if(d(n))return{...n,args:n.args.map(i=>h(i,e,t))};if(typeof n=="object"&&n!==null){let i={};for(let r in n)i[r]=h(n[r],e,t);return i}return n}function $(n){let e=n.args.map(t=>JSON.stringify(t)).join(", ");return`${n.method}(${e})`}function y(n,e,t,i,r){let s={chain:t,run:o=>S(n,o,t,r),goto:o=>{if(!x(o)||o.chain.length===0)throw new Error("Goto must receive a non-empty Fluent");return y(n,e,[...t,...o.chain],i,r)},toString:()=>t.map($).join(".").replace(/\.$/,"")};return new Proxy(s,{get(o,a){if(a in o)return o[a];let f,u;if(p(e)&&a in e)f=e[a],u=`${i}${i?".":""}${a}`;else if(p(n)&&a in n)f=n[a],u=a;else return;if(typeof f=="function")return(...c)=>{let l=u,T={args:c},C=[...t,{method:l,args:T.args,data:{},return:{}}];return y(n,e,C,i,r)};if(p(f))return y(n,f,t,u,r)}})}function F(n,e={}){let t={};for(let i in n)typeof n[i]=="function"?t[i]=n[i].bind(e):typeof n[i]=="object"&&n[i]!==null?t[i]=F(n[i],e):t[i]=n[i];return t}function R(n,e,t){if(!t)return[];let i;return typeof t=="string"?i=new Function("api","fluent",`
      const root = fluent({ api });
      const { ${Object.keys(n).join(",")} } = root;
      const chain = ${t};
      return chain.chain;
    `)(n,m):i=t,i.map(r=>d(r)?{...r,args:r.args.map(s=>h(s,n,e))}:r)}var O=()=>typeof g=="function"?g:typeof globalThis<"u"&&typeof globalThis.setImmediate=="function"?globalThis.setImmediate:(n,...e)=>setTimeout(n,0,...e),g=O();function S(n,e,t,i){let r=e,s=0,o=!1;function a(){if(s>=t.length)return r;let u=t[s];if(d(u)){let c=u.method.split(".").reduce((T,C)=>T[C],n);if(typeof c!="function")throw new Error(`Method ${u.method} not found in API`);let l=c(r,...u.args);if(l instanceof Promise)return l.then(T=>E(n,T,t.slice(s+1),i));r=l===void 0?r:l}return s++,a()}let f=a();return o?new Promise(u=>g(()=>u(f))):f}async function E(n,e,t,i){let r=e,s=0;for(;s<t.length;){let o=t[s];if(d(o)){let a=o.method.split(".").reduce((u,c)=>u[c],n);if(typeof a!="function")throw new Error(`Method ${o.method} not found in API`);let f=await a(r,...o.args);r=f===void 0?r:f}s++}return r}function m(n){let{api:e,ctx:t,chain:i}=n,r=F(e,t),s=R(r,t||{},i),o=(t==null?void 0:t.fluent)||{blocking:!1};return y(r,r,s,"",o)}0&&(module.exports={fluent});
//# sourceMappingURL=index.cjs.map