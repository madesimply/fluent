# Fluent

Fluent is a JavaScript library designed to help you build complex, strongly typed fluent APIs with ease. It provides a flexible and intuitive way to create and execute chains of operations, which can include validations, data transformations, API calls, and more. Fluent simplifies the process of constructing these operation chains. When used effectively, it allows you to write logic that reads like the business requirement equivalent, making it easier to align your code with business rules. Additionally, Fluent's programming paradigm encourages the use of small, reusable methods, which enhances testability and supports robust and reliable development.

# Installation

To install Fluent, use npm:

```bash
npm install fluent
```

# Usage

## Creating a Fluent API

To create a fluent API, use the fluent function and pass in your API structure. The API structure defines the available methods and their expected behavior.

Here we'll create a validator with a namespace for `string` and some chainable methods `min` and `max` for further checks. Well use the context `value` and `errors` props you could do whatever you want with the context. Note we're not throwing any errors, rather we're checking for them. We want to continue execution because we don't know what will happen next in the chain.

```typescript
type Context = {
  value: any,
  errors: string[],
}

const string = (ctx: any) => {
  if (typeof ctx.value !== "string") {
    ctx.errors.push("Value must be a string");
  }
};

const min = (ctx: any, len: number) => {
  string(ctx);
  if (!ctx.errors.length && ctx.value.length < len) {
    ctx.errors.push("String is too short");
  }
}

const max = (ctx: any, len: number) => {
  string(ctx);
  if (!ctx.errors.length && ctx.value.length > len) {
    ctx.errors.push("String is too long");
  }
}

export type Methods = {
  string: {
    min: (len: number) => void,
    max: (len: number) => void,
  };
};

export const methods = {
  string: {
    min,
    max,
  },
};
```

## Building an Operation Chain

Once you have created the fluent API, you can build an operation chain by calling the methods in a fluent manner, chaining one method call after another.

```typescript

const api = {
  validate: methods as Methods
}

const { validate } = fluent(api);

```
What you get is a fully typed exucition chain of all the methods you provided.
```typescript
validate.string.min(2).max(8);
```

## Executing the Operations

To execute the operations defined in your chain, use the run function. This function takes the operation chain, context, and API structure as parameters.

```typescript
// initialize the context

const ctx = { value: 'this string is way too long', errors: [] };
const ops = validate.string.min(2).max(10);

const result = run({ api, ctx, ops })

console.log(result) 
// { value: 'this string is way too long', errors: [ 'String is too long' ] }

```

# API Reference

## fluent(apiStructure)

Parameters:
- `apiStructure`: An object defining the structure and methods of your API. 
- `Returns`: A fluent API instance.

## run({ ops, ctx, api })

Parameters:
- `ops`: The operation chain generated by the fluent API.
- `ctx`: The context object that will be passed to each method in the operation chain.
- `api`: The original API structure.
- `Returns`: The context object after executing the operations. 
- `Returns` a promise if any operations in the chain return a promise.

# Use Case Examples

Fluent can be used in various scenarios. Here are just a few examples to demonstrate its versatility. 

## Common Imports

```typescript
import { methods as stringMethods } from "./validator/string";
import { methods as emailMethods } from "./api/email";
import { methods as userMethods } from "./api/users";
import { fluent, run } from "fluent";
```

## Validation

You can use Fluent to create validator chains:

```typescript
const api = {
  validate: stringMethods,
};

const { validate } = fluent(api);

// make sure this is a valid email
const isEmail = validate.string.pattern(/^[^\s@]+@[^\s@]+.[^\s@]+$/).required;

const emails = ["test@email.com", undefined, 12324, "invalidemail"];

// you can setup your fluent methods to work with any ctx shape you'd like. here we're setting email to ctx.value and errors 
emails.forEach((email) => {
  const result = run({ 
    ops: isEmail, 
    ctx: { value: email, errors: [] }, 
    api 
  });
  console.log(result);
});
```

## Combined and Async Operations

Fluent APIs can be combined/chained and are capable of running async operations such as restful calls:

```typescript
const api = {
  validate: stringMethods,
  server: {
    email: emailMethods,
    user: userMethods,
  },
};

// Combine the validate and server fluent apis
const { validate, server } = fluent(api);

// validate the string is an email
// then try to register the user
// then send a welcome email
const register = 
  validate.string.pattern(/^\S+@\S+.\S+$/).required.
  server.user.register.
  server.user.registered(a.email.welcome);

const emails = ["test@bob.com", undefined];

emails.forEach((email) => {
  const result = run({ 
    ops: register, 
    ctx: { value: email, errors: [] }, 
    api 
  });
  console.log(result);
});
```

See the examples folder for more details.

Don't be limited by these examples, fluent APIs are useful in many other areas such as:
- Data validation and sanitization
- Chaining API calls with structured error handling
- Implementing complex business logic
- Orchestrating multi-step workflows
- Creating reusable and testable methods
- Building dynamic query builders
- Managing feature toggles and configurations
- Handling user authentication and authorization flows
- Aggregating and processing data from multiple sources
- Coordinating event-driven actions

# Contributing

Contributions are welcome! Please open an issue or submit a pull request for any improvements or bug fixes.
