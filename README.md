# Fluent

Fluent is a JavaScript library designed to help you build complex, strongly typed fluent APIs with ease. It provides a flexible and intuitive way to create and execute chains of operations, which can include validations, data transformations, API calls, and more. Fluent simplifies the process of constructing these operation chains. When used effectively, it allows you to write logic that reads like the business requirement equivalent, making it easier to align your code with business rules. Additionally, Fluent's programming paradigm encourages the use of small, reusable methods, which enhances testability and supports robust and reliable development.

# Installation

To install Fluent, use npm:

```bash
npm install fluent
```

# Usage

## Creating a Fluent API

To create a fluent API, use the fluent function and pass in your API structure. The API structure defines the available methods and their expected behavior.

## Building an Operation Chain

Once you have created the fluent API, you can build an operation chain by calling the methods in a fluent manner, chaining one method call after another.

## Executing the Operations

To execute the operations defined in your chain, use the run function. This function takes the operation chain, context, and API structure as parameters.

# API Reference

## fluent(apiStructure)

Parameters:
- `apiStructure`: An object defining the structure and methods of your API. 
- `Returns`: A fluent API instance.

## run({ ops, ctx, api })

Parameters:
- `ops`: The operation chain generated by the fluent API.
- `ctx`: The context object that will be passed to each method in the operation chain.
- `api`: The original API structure.
- `Returns`: The context object after executing the operations. 
- `Returns` a promise if any operations in the chain return a promise.

# Use Case Examples

Fluent can be used in various scenarios. Here are a few examples to demonstrate its versatility:

## Common Imports

```typescript
import { methods as stringMethods } from "./validator/string";
import { methods as emailMethods } from "./api/email";
import { methods as userMethods } from "./api/users";
import { fluent, run } from "fluent";
```

## Validation

You can use Fluent to create validator chains:

```typescript
const api = {
  validate: stringMethods,
};

const { validate } = fluent(api);

// make sure this is a valid email
const isEmail = validate.string.pattern(/^[^\s@]+@[^\s@]+.[^\s@]+$/).required;

const emails = ["test@email.com", undefined, 12324, "invalidemail"];

// you can setup your fluent methods to work with any ctx shape you'd like. here we're setting email to ctx.value and errors 
emails.forEach((email) => {
  const result = run({ 
    ops: isEmail, 
    ctx: { value: email, errors: [] }, 
    api 
  });
  console.log(result);
});
```

## Combined and Async Operations

Fluent APIs can be combined/chained and are capable of running async operations such as restful calls:

```typescript
const api = {
  validate: stringMethods,
  server: {
    email: emailMethods,
    user: userMethods,
  },
};

// Combine the validate and server fluent apis
const { validate, server } = fluent(api);

// validate the string is an email
// then try to register the user
// then send a welcome email
const register = 
  validate.string.pattern(/^\S+@\S+.\S+$/).required.
  server.user.register.
  server.user.registered(a.email.welcome);

const emails = ["test@bob.com", undefined];

emails.forEach((email) => {
  const result = run({ 
    ops: register, 
    ctx: { value: email, errors: [] }, 
    api 
  });
  console.log(result);
});
```

# Contributing

Contributions are welcome! Please open an issue or submit a pull request for any improvements or bug fixes.
